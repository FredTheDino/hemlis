#![allow(unused_extern_crates)]
#![allow(unused_imports)]
use std::str::FromStr;

use crate::ast::*;
use crate::lexer::Token;
use crate::lexer::Lay;

grammar<'t>;

S<T>: S<T> = {
  <l:@L> <t:T> <r:@R> => S(l, t, r),
}

Sep<C, T>: Vec<T> = {
  <e:T> => vec![e],
  <mut v:(<T> C)+> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};

Sep0<C, T>: Vec<T> = {
  <mut v:(<T> C)*> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};

pub QProperName: QProperName<'t> = {
  <xs:S<Qual *>> <n:ProperName> => QProperName(xs, n),
};

pub QName: QName<'t> = {
  <xs:S<Qual *>> <n:Name> => QName(xs, n),
};


pub Qual: Qual<'t> = {
  "qual" => Qual(<>, ),
}

pub ProperName: ProperName<'t> = {
  S<"upper"> => ProperName(<>),
};

pub Name: Name<'t> = {
  S<"lower"> => Name(<>),
};

pub Symbol: Symbol<'t> = {
  S<"symbol"> => Symbol(<>),
};

pub Hole: Hole<'t> = {
  S<"hole"> => Hole(<>),
};

pub Module: Header<'t> = {
  Header => <>,
};


pub Header: Header<'t> = {
  "/0"* "module" <QProperName> <Exports> <Imports> => Header(<>),
};

pub Exports: Vec<Export<'t>> = {
  "(" <Sep<",", Export>> ")" "where" => <>,
  "where" => Vec::new(),
};

pub Export: Export<'t> = {
  Name => Export::Value(<>),
  "(" <Symbol> ")" => Export::Symbol(<>),
  "type" "(" <Symbol> ")" => Export::TypSymbol(<>),
  ProperName => Export::Typ(<>),
  ProperName DataMember => Export::TypDat(<>),
  "class" <ProperName> => Export::Class(<>),
  "module" <QProperName> => Export::Module(<>),
};

pub Imports: Vec<ImportDecl<'t>> = {
  ImportDecl* => <>,
};

pub ImportDecl: ImportDecl<'t> = {
  "/0" "import" <QProperName> "as" <QProperName> => ImportDecl::As(<>),
  "/0" "import" <QProperName> "hiding" "(" <Sep<",", Import>> ")" => ImportDecl::Hiding(<>),
  "/0" "import" <QProperName> "(" <Sep<",", Import>> ")" => ImportDecl::Multiple(<>),
};

pub Import: Import<'t> = {
  Name => Import::Value(<>),
  "(" <Symbol> ")" => Import::Symbol(<>),
  "type" "(" <Symbol> ")" => Import::TypSymbol(<>),
  ProperName => Import::Typ(<>),
  ProperName DataMember => Import::TypDat(<>),
  "class" <ProperName> => Import::Class(<>),
};

pub DataMember: DataMember<'t> = {
  "(" ")" => DataMember::Some(Vec::new()),
  "(" ".." ")" => DataMember::All,
  "(" <Sep<",", ProperName>> ")" => DataMember::Some(<>),
};

extern {
  type Location = usize;
  type Error = ();
  enum Token<'t> {
    "(" => Token::LeftParen,
    ")" => Token::RightParen,
    "{" => Token::LeftBrace,
    "}" => Token::RightBrace,
    "[" => Token::LeftSquare,
    "]" => Token::RightSquare,
    "<-" => Token::LeftArrow,
    "->" => Token::RightArrow,
    "=>" => Token::RightFatArrow,
    "::" => Token::DoubleColon,
    "`" => Token::Tick,
    "," => Token::Comma,

    ".." => Token::Symbol(".."),

    "module" => Token::Lower("module"),
    "where" => Token::Lower("where"),
    "class" => Token::Lower("class"),
    "as" => Token::Lower("as"),
    "import" => Token::Lower("import"),
    "hiding" => Token::Lower("hiding"),
    "type" => Token::Lower("type"),
    "data" => Token::Lower("data"),

    "forall" => Token::Forall,
    "qual" => Token::Qual(<&'t str>),
    "lower" => Token::Lower(<&'t str>),
    "upper" => Token::Upper(<&'t str>),
    "symbol" => Token::Symbol(<&'t str>),
    "hole" => Token::Hole(<&'t str>),
    "hex_int" => Token::HexInt(<&'t str>),
    "number" => Token::Number(<&'t str>),
    "char" => Token::Char(<&'t str>),
    "string" => Token::String(<&'t str>),
    "raw_string" => Token::RawString(<&'t str>),
    "line_comment" => Token::LineComment(<&'t str>),
    "block_comment" => Token::BlockComment(<&'t str>),

    "/{" => Token::LayBegin,
    "/}" => Token::LayEnd,
    "/;" => Token::LaySep,
    "/0" => Token::LayTop,

    // Shouldn't occur
    "_lay" => Token::Lay(<Lay>),
  }
}

