#![allow(unused_extern_crates)]
#![allow(unused_imports)]
use std::str::FromStr;

use crate::ast::*;
use crate::lexer::Token;
use crate::lexer::Lay;

grammar<'t>;

S<T>: S<T> = {
  @L T @R => S(l, t, r),
}

B<T>: Box<T> = {
  T => Box::new(<>),
}

#[inline]
Sep<C, T>: Vec<T> = {
  <e:T> => vec![e],
  <mut v:(<T> C)+> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};

#[inline]
Sep0<C, T>: Vec<T> = {
  <mut v:(<T> C)*> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};

#[inline]
QProperName: QProperName<'t> = { S<Qual+>? ProperName => QProperName(<>) };

#[inline]
QName: QName<'t> = { S<Qual+>? Name => QName(<>) };

#[inline]
Qual: Qual<'t> = { "qual" => Qual(<>, ), }

#[inline]
ProperName: ProperName<'t> = { S<"upper"> => ProperName(<>), };

#[inline]
Name: Name<'t> = { S<"lower"> => Name(<>), };

#[inline]
Str: Str<'t> = {
  S<"string"> => Str(<>),
  S<"raw_string"> => Str(<>),
};
#[inline]
Number: Number<'t> = { S<"number"> => Number(<>), };
#[inline]
Char: Char<'t> = { S<"char"> => Char(<>), };
#[inline]
Boolean: Boolean<'t> = {
  <l:@L> "true" <r:@R> => Boolean(S(l, "true", r)),
  <l:@L> "false" <r:@R> => Boolean(S(l, "false", r)), 
};

#[inline]
Symbol: Symbol<'t> = { "(" S<"symbol"> ")" => Symbol(<>) };
#[inline]
QSymbol: QSymbol<'t> = { S<Qual+>? Symbol => Symbol(<>) };

#[inline]
Op: Op<'t> = { S<"symbol"> => Op(<>) };
#[inline]
QOp: QOp<'t> = { S<Qual+>? Op => QOp(<>) };

#[inline]
Hole: Hole<'t> = { S<"hole"> => Hole(<>), };

pub Module: Module<'t> = { Header Sep0<"/0", Decl> => Module(<>), };


pub Header: Header<'t> = {
  "/0"* "module" <QProperName> <Exports> <Imports> => Header(<>),
};

pub Exports: Vec<Export<'t>> = {
  "(" <Sep<",", Export>> ")" "where" => <>,
  "where" => Vec::new(),
};

pub Export: Export<'t> = {
  Name => Export::Value(<>),
  <Symbol> => Export::Symbol(<>),
  "type" <Symbol> => Export::TypSymbol(<>),
  ProperName => Export::Typ(<>),
  ProperName DataMember => Export::TypDat(<>),
  "class" <ProperName> => Export::Class(<>),
  "module" <QProperName> => Export::Module(<>),
};

pub Imports: Vec<ImportDecl<'t>> = {
  ImportDecl* => <>,
};

pub ImportDecl: ImportDecl<'t> = {
  "/0" "import" <QProperName> "as" <QProperName> => ImportDecl::As(<>),
  "/0" "import" <QProperName> "hiding" "(" <Sep<",", Import>> ")" => ImportDecl::Hiding(<>),
  "/0" "import" <QProperName> "(" <Sep<",", Import>> ")" => ImportDecl::Multiple(<>),
};

pub Import: Import<'t> = {
  Name => Import::Value(<>),
  <Symbol> => Import::Symbol(<>),
  "type" <Symbol> => Import::TypSymbol(<>),
  ProperName => Import::Typ(<>),
  ProperName DataMember => Import::TypDat(<>),
  "class" <ProperName> => Import::Class(<>),
};

pub DataMember: DataMember<'t> = {
  "(" ")" => DataMember::Some(Vec::new()),
  "(" ".." ")" => DataMember::All,
  "(" <Sep<",", ProperName>> ")" => DataMember::Some(<>),
};

pub Decl : Decl<'t> = {
  "data" <ProperName> "::" <Typ> => Decl::DataKind(<>),
  "data" <ProperName> <SimpleTypVarBinding*> ("=" (<DataCtr> "|")+)? => Decl::Data(<>),

  "type" <ProperName> "::" <Typ> => Decl::TypeKind(<>),
  "type" <ProperName> <SimpleTypVarBinding*> "=" <Typ> => Decl::Type(<>),

  "newtype" <ProperName> "::" <Typ> => Decl::NewTypeKind(<>),
  "newtype" <ProperName> <SimpleTypVarBinding*> "=" <TypAtom> => Decl::NewType(<>),

  "class" <ClassHead> "where" "/{" <Sep<"/;", ClassMember>> "/}" "/0" => Decl::Class(<>),
  "class" <ClassHead> "/0" => Decl::Class(<>, Vec::new()),
}

ClassMember : ClassMember<'t> = {
  <Name> "::" <Typ> => ClassMember(<>),
}

ClassHead : ClassHead<'t> = {
  Constraints? ProperName TypVarBinding* FunDeps => ClassHead(<>),
}

TypVarBinding : TypVarBinding<'t> = {
  "@" <Name> => TypVarBinding(<>, None, true),
  "(" "@" <Name> "::" <Typ> ")" => TypVarBinding(<>, true),
  SimpleTypVarBinding => <>,
}

SimpleTypVarBinding : TypVarBinding<'t> = {
  <Name> => TypVarBinding(<>, None, false),
  "(" <Name> "::" <Typ> ")" => TypVarBinding(<>, false),
}

Constraints : Vec<Constraint<'t>> = {
  "(" <Sep<",", Constraint>> ")" "<=" => <>,
  Constraint "<=" => vec![<>],
}

Constraint : Constraint<'t> = {
  "(" <Constraint> ")" => <>,
  QProperName TypAtom* => Constraint(<>),
}

#[inline]
FunDeps : Vec<FunDep<'t>> = {
  "|" <Sep<",", FunDep>> => <>,
  => Vec::new(),
}

#[inline]
FunDep : FunDep<'t> = {
  "->" <Name+> => FunDep(_, <>),
  <Name+> "->" <Name+> => FunDep(<>),
}

DataCtr : (ProperName<'t>, Vec<Typ<'t>>) = {
  ProperName TypAtom* => <>
}

pub Typ : Typ<'t> = {
  Typ1 => <>,
  <B<Typ1>> "::" <B<Typ>> => Typ::Kinded(<>),
}

Typ1 : Typ<'t> = {
  Typ2 => <>,
  "forall" <TypVarBinding*> "." <B<Typ1>> => Typ::Forall(<>),
}

Typ2 : Typ<'t> = {
  Typ3 => <>,
  <B<Typ3>> "->" <B<Typ1>> => Typ::Arr(<>),
  // This is correct, right?
  <Constraint> "=>" <B<Typ1>> => Typ::Constrained(<>),
}

Typ3 : Typ<'t> = {
  Typ4 => <>,
  <B<Typ3>> <QOp> <B<Typ4>> => Typ::Op(<>),
}

Typ4 : Typ<'t> = {
  Typ5 => <>,
  // "-" Int => ??,
}

Typ5 : Typ<'t> = {
  TypAtom => <>,
  B<Typ5> B<TypAtom> => Typ::App(<>),
}

TypAtom : Typ<'t> = {
  "_" => Typ::Wildcard,
  Name => Typ::Var(<>),
  QProperName => Typ::Constructor(<>), 
  QSymbol => Typ::Symbol(<>),
  Str => Typ::Str(<>),
  // Int => Typ::Int(<>),
  Hole => Typ::Hole(<>),
  // ?????
  // | "(->)" { TypeArrName () $1 }
  <@L> "{" <Row> "}" <@R> => Typ::Row(S(<>)),
  <@L> "(" <Row> ")" <@R> => Typ::Record(S(<>)),
  "(" <Typ> ")" => <>,
}

Row : Row<'t> = {
  <x:Sep<",", RowLabel>> => Row(x, None),
  <x:Sep<",", RowLabel>> "|" <t:Typ> => Row(x, Some(t)),
  "|" <t:Typ> => Row(Vec::new(), Some(t)),
  => Row(Vec::new(), None),
}

RowLabel : (Label<'t>, Typ<'t>) = {
  <Label> "::" <Typ> => (<>),
}

Label : Label<'t> = {
  S<"lower"> => Label(<>),
  S<"string"> => Label(<>),
  S<"raw_string"> => Label(<>),
}

pub WorstCase : Result<(Binder<'t>, Expr<'t>), (Expr<'t>)> = {
  <Binder> "<-" <Expr> => Ok((<>)),
  <Expr> => Err(<>),
}

pub Expr : Expr<'t> = {
  Number => Expr::Number(<>),
  QName => Expr::Var(<>),
}

pub Binder : Binder<'t> = {
  Number => Binder::Number(<>),
  Name => Binder::Var(<>),
}

extern {
  type Location = usize;
  type Error = ();
  enum Token<'t> {
    "(" => Token::LeftParen,
    ")" => Token::RightParen,
    "{" => Token::LeftBrace,
    "}" => Token::RightBrace,
    "[" => Token::LeftSquare,
    "]" => Token::RightSquare,
    "<-" => Token::LeftArrow,
    "->" => Token::RightArrow,
    "=>" => Token::RightFatArrow,
    "::" => Token::DoubleColon,
    "`" => Token::Tick,
    "," => Token::Comma,

    "<=" => Token::Symbol("<="),
    "@" => Token::Symbol("@"),
    "|" => Token::Symbol("|"),
    "." => Token::Symbol("."),
    "=" => Token::Symbol("="),
    ".." => Token::Symbol(".."),
    "_" => Token::Lower("_"),

    "module" => Token::Lower("module"),
    "where" => Token::Lower("where"),
    "class" => Token::Lower("class"),
    "as" => Token::Lower("as"),
    "import" => Token::Lower("import"),
    "hiding" => Token::Lower("hiding"),
    "type" => Token::Lower("type"),
    "newtype" => Token::Lower("newtype"),
    "data" => Token::Lower("data"),
    "true" => Token::Lower("true"),
    "false" => Token::Lower("false"),

    "forall" => Token::Forall,
    "qual" => Token::Qual(<&'t str>),
    "lower" => Token::Lower(<&'t str>),
    "upper" => Token::Upper(<&'t str>),
    "symbol" => Token::Symbol(<&'t str>),
    "hole" => Token::Hole(<&'t str>),
    "hex_int" => Token::HexInt(<&'t str>),
    "number" => Token::Number(<&'t str>),
    "char" => Token::Char(<&'t str>),
    "string" => Token::String(<&'t str>),
    "raw_string" => Token::RawString(<&'t str>),
    "line_comment" => Token::LineComment(<&'t str>),
    "block_comment" => Token::BlockComment(<&'t str>),

    "/{" => Token::LayBegin,
    "/}" => Token::LayEnd,
    "/;" => Token::LaySep,
    "/0" => Token::LayTop,
  }
}

